package main

import (
	"bufio"
	"bytes"
	"crypto/rand"
	"crypto/rsa"
	"crypto/x509"
	"encoding/json"
	"encoding/pem"
	"fmt"
	"io"
	"log"
	"net"
	"net/http"
	"os"
	"strings"
	"sync"
	"time"
	"unicode/utf8"

	"golang.org/x/crypto/ssh"
	"gopkg.in/yaml.v2"
)

// 配置加载函数
func loadConfig() error {
	data, err := os.ReadFile("config.yaml")
	if err != nil {
		return fmt.Errorf("读取配置文件失败: %v", err)
	}

	err = yaml.Unmarshal(data, &config)
	if err != nil {
		return fmt.Errorf("解析配置文件失败: %v", err)
	}

	return nil
}

// 配置结构体
type Config struct {
	Server struct {
		Port           string `yaml:"port"`
		WelcomeMessage string `yaml:"welcome_message"`
		PromptTemplate string `yaml:"prompt_template"`
	} `yaml:"server"`
	API struct {
		BaseURL      string `yaml:"base_url"`
		APIKey       string `yaml:"api_key"`
		DefaultModel string `yaml:"default_model"`
		Timeout      int    `yaml:"timeout"`
	} `yaml:"api"`
	Display struct {
		LineWidth                 int `yaml:"line_width"`
		ThinkingAnimationInterval int `yaml:"thinking_animation_interval"`
		LoadingAnimationInterval  int `yaml:"loading_animation_interval"`
	} `yaml:"display"`
	Security struct {
		HostKeyFile string `yaml:"host_key_file"`
	} `yaml:"security"`
}

// 全局配置变量
var config Config

// OpenAI API 请求结构体
type ChatMessage struct {
	Role    string `json:"role"`
	Content string `json:"content"`
}

type ChatRequest struct {
	Model    string        `json:"model"`
	Messages []ChatMessage `json:"messages"`
	Stream   bool          `json:"stream"`
}

type ChatResponse struct {
	ID      string `json:"id"`
	Object  string `json:"object"`
	Created int64  `json:"created"`
	Model   string `json:"model"`
	Choices []struct {
		Index int `json:"index"`
		Delta struct {
			Role             string `json:"role,omitempty"`
			Content          string `json:"content,omitempty"`
			Reasoning        string `json:"reasoning,omitempty"`
			ReasoningContent string `json:"reasoning_content,omitempty"`
		} `json:"delta"`
		FinishReason *string `json:"finish_reason"`
	} `json:"choices"`
}

// 模型信息结构体
type ModelInfo struct {
	ID      string `json:"id"`
	Object  string `json:"object"`
	Created int64  `json:"created"`
	OwnedBy string `json:"owned_by"`
}

type ModelsResponse struct {
	Object string      `json:"object"`
	Data   []ModelInfo `json:"data"`
}

// AIAssistant 真实AI助手
type AIAssistant struct {
	messages      []ChatMessage
	currentModel  string
	username      string
	thinkingStart time.Time
}

func NewAIAssistant(username string) *AIAssistant {
	return &AIAssistant{
		messages:     make([]ChatMessage, 0),
		currentModel: config.API.DefaultModel,
		username:     username,
	}
}

func (ai *AIAssistant) ClearContext() {
	ai.messages = make([]ChatMessage, 0)
}

// 获取可用模型列表
func getAvailableModels() ([]ModelInfo, error) {
	req, err := http.NewRequest("GET", config.API.BaseURL+"/models", nil)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", "Bearer "+config.API.APIKey)

	client := &http.Client{Timeout: 10 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("API错误: %d", resp.StatusCode)
	}

	var modelsResp ModelsResponse
	if err := json.NewDecoder(resp.Body).Decode(&modelsResp); err != nil {
		return nil, err
	}

	return modelsResp.Data, nil
}

// 根据用户名匹配模型
func matchModelsByUsername(models []ModelInfo, username string) []ModelInfo {
	if username == "" {
		return models
	}

	var matched []ModelInfo
	username = strings.ToLower(username)

	for _, model := range models {
		modelName := strings.ToLower(model.ID)
		if strings.Contains(modelName, username) {
			matched = append(matched, model)
		}
	}

	return matched
}

// 显示模型选择菜单
func showModelSelection(channel ssh.Channel, models []ModelInfo, username string, allModels []ModelInfo) string {
	if len(models) == 0 {
		if len(allModels) > 0 {
			channel.Write([]byte(fmt.Sprintf("\r\n没有找到与用户名 '%s' 匹配的模型，显示所有可用模型:\r\n", username)))
			models = allModels
		} else {
			channel.Write([]byte("\r\n没有找到可用的模型\r\n"))
			return config.API.DefaultModel
		}
	}

	if len(models) == 1 {
		selectedModel := models[0].ID
		if username != "" {
			channel.Write([]byte(fmt.Sprintf("\r\n已为用户 '%s' 自动选择模型: %s\r\n", username, selectedModel)))
		} else {
			channel.Write([]byte(fmt.Sprintf("\r\n已自动选择模型: %s\r\n", selectedModel)))
		}
		return selectedModel
	}

	// 显示模型列表
	if username != "" {
		channel.Write([]byte(fmt.Sprintf("\r\n为用户 '%s' 找到以下匹配的模型:\r\n", username)))
	} else {
		channel.Write([]byte("\r\n可用模型列表:\r\n"))
	}

	for i, model := range models {
		channel.Write([]byte(fmt.Sprintf("%d. %s\r\n", i+1, model.ID)))
	}

	channel.Write([]byte("\r\n请选择模型 (输入数字): "))

	// 读取用户选择 - 改进的输入处理
	var inputBuffer []byte
	var incompleteUTF8 []byte
	buffer := make([]byte, 1024)

	for {
		n, err := channel.Read(buffer)
		if err != nil {
			return config.API.DefaultModel
		}

		data := buffer[:n]

		// 处理可能的不完整UTF-8序列
		if len(incompleteUTF8) > 0 {
			data = append(incompleteUTF8, data...)
			incompleteUTF8 = nil
		}

		// 处理UTF-8字符
		for len(data) > 0 {
			r, size := utf8.DecodeRune(data)

			if r == utf8.RuneError && size == 1 {
				// 可能是不完整的UTF-8序列
				if len(data) < 4 {
					incompleteUTF8 = make([]byte, len(data))
					copy(incompleteUTF8, data)
					break
				}
				// 跳过无效字节
				data = data[1:]
				continue
			}

			data = data[size:]

			switch r {
			case '\r', '\n':
				// 处理回车换行
				if len(inputBuffer) > 0 {
					input := strings.TrimSpace(string(inputBuffer))
					inputBuffer = nil

					if input == "" {
						channel.Write([]byte("\r\n请输入有效的数字: "))
						continue
					}

					// 解析选择
					choice := 0
					if _, err := fmt.Sscanf(input, "%d", &choice); err != nil {
						channel.Write([]byte("\r\n无效输入，请输入数字: "))
						continue
					}

					if choice < 1 || choice > len(models) {
						channel.Write([]byte(fmt.Sprintf("\r\n请输入 1-%d 之间的数字: ", len(models))))
						continue
					}

					selectedModel := models[choice-1].ID
					channel.Write([]byte(fmt.Sprintf("\r\n已选择模型: %s\r\n", selectedModel)))
					return selectedModel
				} else {
					channel.Write([]byte("\r\n请输入有效的数字: "))
				}

			case 127, 8: // Backspace/Delete
				if len(inputBuffer) > 0 {
					// 删除最后一个UTF-8字符
					inputStr := string(inputBuffer)
					if len(inputStr) > 0 {
						runes := []rune(inputStr)
						if len(runes) > 0 {
							lastRune := runes[len(runes)-1]
							newStr := string(runes[:len(runes)-1])
							inputBuffer = []byte(newStr)

							// 根据字符宽度发送退格序列
							if utf8.RuneLen(lastRune) > 1 {
								// 中文字符需要两个退格
								channel.Write([]byte("\b \b\b \b"))
							} else {
								// 英文字符一个退格
								channel.Write([]byte("\b \b"))
							}
						}
					}
				}

			case 3: // Ctrl+C
				channel.Write([]byte("\r\n^C\r\n"))
				return config.API.DefaultModel

			default:
				// 处理数字输入
				if r >= '0' && r <= '9' {
					runeBytes := make([]byte, utf8.RuneLen(r))
					utf8.EncodeRune(runeBytes, r)
					inputBuffer = append(inputBuffer, runeBytes...)
					channel.Write(runeBytes) // 回显字符
				}
			}
		}
	}
}

func (ai *AIAssistant) ProcessMessage(input string, channel ssh.Channel, interrupt chan bool) {
	input = strings.TrimSpace(input)

	// 检查特殊命令
	if strings.ToLower(input) == "/new" {
		ai.ClearContext()
		channel.Write([]byte("\r\n[新会话已创建]\r\n"))
		return
	}

	if input == "" {
		return
	}

	// 添加用户消息到上下文
	ai.messages = append(ai.messages, ChatMessage{
		Role:    "user",
		Content: input,
	})

	// 显示加载动画并调用AI API
	ai.callAIAPIWithLoading(channel, interrupt)
}

// 显示加载动画的AI API调用
func (ai *AIAssistant) callAIAPIWithLoading(channel ssh.Channel, interrupt chan bool) {
	// 启动加载动画
	var wg sync.WaitGroup
	stopLoading := make(chan bool)

	wg.Add(1)
	go func() {
		defer wg.Done()
		ai.showLoadingAnimation(channel, stopLoading)
	}()

	// 调用AI API
	ai.callAIAPI(channel, stopLoading, interrupt)

	// 等待加载动画结束
	wg.Wait()
}

// 加载动画
func (ai *AIAssistant) showLoadingAnimation(channel ssh.Channel, stop chan bool) {
	loadingChars := []string{"⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏"}
	i := 0

	channel.Write([]byte("\r\n"))

	ticker := time.NewTicker(100 * time.Millisecond)
	defer ticker.Stop()

	for {
		select {
		case <-stop:
			// 清除加载动画
			channel.Write([]byte("\r\033[K"))
			return
		case <-ticker.C:
			// 显示加载动画
			channel.Write([]byte(fmt.Sprintf("\r%s ", loadingChars[i%len(loadingChars)])))
			i++
		}
	}
}

// 思考动画
func (ai *AIAssistant) showThinkingAnimation(channel ssh.Channel, interrupt chan bool) {
	thinkingChars := []string{"⠋", "⠙", "⠹", "⠸", "⠼", "⠴", "⠦", "⠧", "⠇", "⠏"}
	i := 0

	channel.Write([]byte("\r\n--- 思考中 ---\r\n"))

	ticker := time.NewTicker(100 * time.Millisecond)
	defer ticker.Stop()

	for {
		select {
		case <-interrupt:
			// 清除思考动画
			channel.Write([]byte("\r\033[K"))
			return
		case <-ticker.C:
			// 显示思考动画
			channel.Write([]byte(fmt.Sprintf("\r%s 思考中...", thinkingChars[i%len(thinkingChars)])))
			i++
		}
	}
}

// 自动换行函数
func wrapText(text string, width int) string {
	if width <= 0 {
		return text
	}

	var result strings.Builder
	var currentLine strings.Builder
	var currentWidth int

	for _, r := range text {
		if r == '\n' {
			result.WriteString(currentLine.String())
			result.WriteRune('\n')
			currentLine.Reset()
			currentWidth = 0
			continue
		}

		runeWidth := 1
		if utf8.RuneLen(r) > 1 {
			runeWidth = 2 // 中文字符占2个宽度
		}

		if currentWidth+runeWidth > width && currentLine.Len() > 0 {
			result.WriteString(currentLine.String())
			result.WriteString("\r\n")
			currentLine.Reset()
			currentWidth = 0
		}

		currentLine.WriteRune(r)
		currentWidth += runeWidth
	}

	if currentLine.Len() > 0 {
		result.WriteString(currentLine.String())
	}

	return result.String()
}

func (ai *AIAssistant) callAIAPI(channel ssh.Channel, stopLoading chan bool, interrupt chan bool) {
	// 构建请求
	request := ChatRequest{
		Model:    ai.currentModel,
		Messages: ai.messages,
		Stream:   true,
	}

	jsonData, err := json.Marshal(request)
	if err != nil {
		stopLoading <- true
		channel.Write([]byte(fmt.Sprintf("\r\n[错误: %v]\r\n", err)))
		return
	}

	// 创建HTTP请求
	req, err := http.NewRequest("POST", config.API.BaseURL+"/chat/completions", bytes.NewBuffer(jsonData))
	if err != nil {
		stopLoading <- true
		channel.Write([]byte(fmt.Sprintf("\r\n[错误: %v]\r\n", err)))
		return
	}

	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+config.API.APIKey)

	// 发送请求
	client := &http.Client{Timeout: time.Duration(config.API.Timeout) * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		stopLoading <- true
		channel.Write([]byte(fmt.Sprintf("\r\n[网络错误: %v]\r\n", err)))
		return
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		stopLoading <- true
		channel.Write([]byte(fmt.Sprintf("\r\n[API错误: %d]\r\n", resp.StatusCode)))
		return
	}

	// 处理流式响应
	scanner := bufio.NewScanner(resp.Body)
	var assistantMessage strings.Builder
	var currentLine strings.Builder
	const lineWidth = 80 // 终端宽度

	isThinking := false
	hasContent := false

	for scanner.Scan() {
		// 检查是否被中断
		select {
		case <-interrupt:
			if !hasContent {
				stopLoading <- true
			}
			channel.Write([]byte("\r\n[回答已中断]\r\n"))
			return
		default:
		}

		line := scanner.Text()
		if !strings.HasPrefix(line, "data: ") {
			continue
		}

		data := strings.TrimPrefix(line, "data: ")
		if data == "[DONE]" {
			break
		}

		var response ChatResponse
		if err := json.Unmarshal([]byte(data), &response); err != nil {
			continue
		}

		if len(response.Choices) > 0 {
			choice := response.Choices[0]

			// 检查是否有思考内容 (支持多种字段名)
			thinkingContent := ""
			if choice.Delta.Reasoning != "" {
				thinkingContent = choice.Delta.Reasoning
			} else if choice.Delta.ReasoningContent != "" {
				thinkingContent = choice.Delta.ReasoningContent
			}

			if thinkingContent != "" {
				if !isThinking {
					// 第一次收到思考内容，停止普通加载动画，显示思考状态
					stopLoading <- true
					isThinking = true
					ai.thinkingStart = time.Now()
					channel.Write([]byte("\r\033[K🤖 Thinking\r\n"))
				}

				// 直接显示思考内容，不显示动画
				reasoning := thinkingContent
				for _, r := range reasoning {
					if r == '\n' {
						channel.Write([]byte(currentLine.String() + "\r\n"))
						currentLine.Reset()
					} else {
						currentLine.WriteRune(r)
						if ai.getDisplayWidth(currentLine.String()) >= lineWidth {
							lineStr := currentLine.String()
							breakPos := ai.findBreakPosition(lineStr, lineWidth)
							if breakPos > 0 {
								channel.Write([]byte(lineStr[:breakPos] + "\r\n"))
								currentLine.Reset()
								currentLine.WriteString(lineStr[breakPos:])
							} else {
								channel.Write([]byte(currentLine.String() + "\r\n"))
								currentLine.Reset()
							}
						}
					}
				}
			}

			// 检查是否有回答内容
			if choice.Delta.Content != "" {
				if !hasContent {
					// 第一次收到回答内容
					if isThinking {
						// 如果之前在思考，先输出剩余思考内容并显示完成状态
						if currentLine.Len() > 0 {
							channel.Write([]byte(currentLine.String() + "\r\n"))
							currentLine.Reset()
						}
						// 计算思考时间
						thinkingDuration := time.Since(ai.thinkingStart)
						channel.Write([]byte(fmt.Sprintf("✅ Done： %.1fs\r\n", thinkingDuration.Seconds())))
					} else {
						stopLoading <- true
					}
					hasContent = true
				}

				content := choice.Delta.Content
				assistantMessage.WriteString(content)

				// 处理自动换行
				for _, r := range content {
					if r == '\n' {
						channel.Write([]byte(currentLine.String() + "\r\n"))
						currentLine.Reset()
					} else {
						currentLine.WriteRune(r)
						if ai.getDisplayWidth(currentLine.String()) >= lineWidth {
							lineStr := currentLine.String()
							breakPos := ai.findBreakPosition(lineStr, lineWidth)
							if breakPos > 0 {
								channel.Write([]byte(lineStr[:breakPos] + "\r\n"))
								currentLine.Reset()
								currentLine.WriteString(lineStr[breakPos:])
							} else {
								channel.Write([]byte(currentLine.String() + "\r\n"))
								currentLine.Reset()
							}
						}
					}
				}
			}
		}
	}

	// 如果没有收到任何内容，停止加载动画
	if !hasContent && !isThinking {
		stopLoading <- true
	}

	// 输出剩余内容
	if currentLine.Len() > 0 {
		channel.Write([]byte(currentLine.String()))
	}

	// 将助手回复添加到上下文
	if assistantMessage.Len() > 0 {
		ai.messages = append(ai.messages, ChatMessage{
			Role:    "assistant",
			Content: assistantMessage.String(),
		})
	}

	channel.Write([]byte("\r\n"))
}

// 计算显示宽度（中文字符占2个宽度）
func (ai *AIAssistant) getDisplayWidth(text string) int {
	width := 0
	for _, r := range text {
		if utf8.RuneLen(r) > 1 {
			width += 2 // 中文字符
		} else {
			width += 1 // 英文字符
		}
	}
	return width
}

// 寻找合适的断行位置
func (ai *AIAssistant) findBreakPosition(text string, maxWidth int) int {
	if len(text) == 0 {
		return 0
	}

	// 寻找空格、标点符号等合适的断行位置
	breakChars := []rune{' ', ',', '.', '!', '?', ';', ':', '，', '。', '！', '？', '；', '：'}

	currentWidth := 0
	lastBreakBytePos := 0
	currentBytePos := 0

	for _, r := range text {
		runeWidth := 1
		if utf8.RuneLen(r) > 1 {
			runeWidth = 2
		}

		currentWidth += runeWidth

		// 检查是否是断行字符
		for _, bc := range breakChars {
			if r == bc {
				lastBreakBytePos = currentBytePos + utf8.RuneLen(r)
				break
			}
		}

		if currentWidth >= maxWidth {
			if lastBreakBytePos > 0 {
				return lastBreakBytePos
			}
			// 如果没有找到合适的断行位置，返回当前字符的起始位置
			return currentBytePos
		}

		currentBytePos += utf8.RuneLen(r)
	}

	return 0
}

// 生成或加载RSA主机密钥
func generateHostKey() (ssh.Signer, error) {
	keyFile := config.Security.HostKeyFile

	// 尝试加载现有密钥
	if keyData, err := os.ReadFile(keyFile); err == nil {
		privateKey, err := ssh.ParsePrivateKey(keyData)
		if err == nil {
			log.Printf("已加载现有主机密钥")
			return privateKey, nil
		}
		log.Printf("无法解析现有密钥文件，将生成新密钥: %v", err)
	}

	// 生成新的RSA私钥
	privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
	if err != nil {
		return nil, err
	}

	// 将私钥转换为SSH签名器
	signer, err := ssh.NewSignerFromKey(privateKey)
	if err != nil {
		return nil, err
	}

	// 保存私钥到文件
	keyBytes := x509.MarshalPKCS1PrivateKey(privateKey)
	keyPEM := pem.EncodeToMemory(&pem.Block{
		Type:  "RSA PRIVATE KEY",
		Bytes: keyBytes,
	})

	if err := os.WriteFile(keyFile, keyPEM, 0600); err != nil {
		log.Printf("警告：无法保存主机密钥: %v", err)
	} else {
		log.Printf("已生成并保存新的主机密钥")
	}

	return signer, nil
}

func handleSSHConnection(conn net.Conn, config *ssh.ServerConfig) {
	defer conn.Close()

	// SSH握手
	sshConn, chans, reqs, err := ssh.NewServerConn(conn, config)
	if err != nil {
		log.Printf("Failed to handshake: %v", err)
		return
	}
	defer sshConn.Close()

	// 获取用户名
	username := sshConn.User()
	log.Printf("New SSH connection from %s (%s), user: %s", sshConn.RemoteAddr(), sshConn.ClientVersion(), username)

	// 处理全局请求
	go ssh.DiscardRequests(reqs)

	// 处理通道
	for newChannel := range chans {
		if newChannel.ChannelType() != "session" {
			newChannel.Reject(ssh.UnknownChannelType, "unknown channel type")
			continue
		}

		channel, requests, err := newChannel.Accept()
		if err != nil {
			log.Printf("Could not accept channel: %v", err)
			continue
		}

		go handleSession(channel, requests, username)
	}
}

func handleSession(channel ssh.Channel, requests <-chan *ssh.Request, username string) {
	defer channel.Close()

	// 发送欢迎消息
	if username != "" {
		channel.Write([]byte(fmt.Sprintf("欢迎, %s!\r\n", username)))
	} else {
		channel.Write([]byte(config.Server.WelcomeMessage + "\r\n"))
	}

	// 获取并选择模型
	channel.Write([]byte("正在获取可用模型...\r\n"))
	models, err := getAvailableModels()
	if err != nil {
		channel.Write([]byte(fmt.Sprintf("获取模型列表失败: %v\r\n", err)))
		channel.Write([]byte(fmt.Sprintf("使用默认模型: %s\r\n", config.API.DefaultModel)))
		models = []ModelInfo{{ID: config.API.DefaultModel}}
	}

	// 根据用户名匹配模型
	matchedModels := matchModelsByUsername(models, username)
	selectedModel := showModelSelection(channel, matchedModels, username, models)

	// 创建AI助手实例
	ai := NewAIAssistant(username)
	ai.currentModel = selectedModel
	interrupt := make(chan bool, 1)

	// 显示对话提示符
	dynamicPrompt := fmt.Sprintf(config.Server.PromptTemplate, selectedModel)
	channel.Write([]byte("\r\n" + dynamicPrompt))

	// 处理会话请求
	go func() {
		for req := range requests {
			switch req.Type {
			case "shell", "exec":
				req.Reply(true, nil)
			case "pty-req":
				req.Reply(true, nil)
			default:
				req.Reply(false, nil)
			}
		}
	}()

	// 主要的交互循环 - 支持UTF-8输入
	buffer := make([]byte, 4096) // 增大缓冲区以支持UTF-8
	var inputBuffer []byte
	var incompleteUTF8 []byte

	for {
		n, err := channel.Read(buffer)
		if err != nil {
			if err != io.EOF {
				log.Printf("Read error: %v", err)
			}
			break
		}

		data := buffer[:n]

		// 处理可能的不完整UTF-8序列
		if len(incompleteUTF8) > 0 {
			data = append(incompleteUTF8, data...)
			incompleteUTF8 = nil
		}

		// 处理UTF-8字符
		for len(data) > 0 {
			r, size := utf8.DecodeRune(data)

			if r == utf8.RuneError && size == 1 {
				// 可能是不完整的UTF-8序列
				if len(data) < 4 {
					incompleteUTF8 = make([]byte, len(data))
					copy(incompleteUTF8, data)
					break
				}
				// 跳过无效字节
				data = data[1:]
				continue
			}

			data = data[size:]

			switch r {
			case '\r', '\n':
				// 处理回车换行
				if len(inputBuffer) > 0 {
					input := string(inputBuffer)
					inputBuffer = nil

					// 检查退出命令
					if strings.ToLower(strings.TrimSpace(input)) == "exit" {
						channel.Write([]byte("\r\nGoodbye!\r\n"))
						return
					}

					// 调用AI处理消息
					ai.ProcessMessage(input, channel, interrupt)
				} else {
					channel.Write([]byte("\r\n"))
				}
				channel.Write([]byte(dynamicPrompt))

			case 127, 8: // Backspace/Delete
				if len(inputBuffer) > 0 {
					// 删除最后一个UTF-8字符
					inputStr := string(inputBuffer)
					if len(inputStr) > 0 {
						runes := []rune(inputStr)
						if len(runes) > 0 {
							lastRune := runes[len(runes)-1]
							newStr := string(runes[:len(runes)-1])
							inputBuffer = []byte(newStr)

							// 根据字符宽度发送退格序列
							if utf8.RuneLen(lastRune) > 1 {
								// 中文字符需要两个退格
								channel.Write([]byte("\b \b\b \b"))
							} else {
								// 英文字符一个退格
								channel.Write([]byte("\b \b"))
							}
						}
					}
				}

			case 3: // Ctrl+C
				// 发送中断信号
				select {
				case interrupt <- true:
				default:
				}
				channel.Write([]byte("\r\n^C\r\n"))
				channel.Write([]byte(dynamicPrompt))
				inputBuffer = nil

			default:
				// 处理所有可打印字符，包括中文
				if r >= 32 || (r > 127 && utf8.ValidRune(r)) {
					runeBytes := make([]byte, utf8.RuneLen(r))
					utf8.EncodeRune(runeBytes, r)
					inputBuffer = append(inputBuffer, runeBytes...)
					channel.Write(runeBytes) // 回显字符
				}
			}
		}
	}
}

func main() {
	// 加载配置文件
	err := loadConfig()
	if err != nil {
		log.Fatal("Failed to load config:", err)
	}

	// 生成主机密钥
	hostKey, err := generateHostKey()
	if err != nil {
		log.Fatal("Failed to generate host key:", err)
	}

	// SSH服务器配置
	sshConfig := &ssh.ServerConfig{
		// 无密码认证 - 接受所有连接
		NoClientAuth: true,
		// 或者使用密码回调来接受任何密码
		PasswordCallback: func(conn ssh.ConnMetadata, password []byte) (*ssh.Permissions, error) {
			// 接受任何用户名和密码
			log.Printf("Login attempt: user=%s", conn.User())
			return nil, nil
		},
		PublicKeyCallback: func(conn ssh.ConnMetadata, key ssh.PublicKey) (*ssh.Permissions, error) {
			// 接受任何公钥
			return nil, nil
		},
	}

	sshConfig.AddHostKey(hostKey)

	// 监听端口
	listener, err := net.Listen("tcp", ":"+config.Server.Port)
	if err != nil {
		log.Fatal("Failed to listen on port", config.Server.Port, ":", err)
	}
	defer listener.Close()

	log.Printf("SSH AI Server listening on port %s", config.Server.Port)
	log.Printf("Connect with: ssh gpt-5@localhost -p %s", config.Server.Port)

	// 接受连接
	for {
		conn, err := listener.Accept()
		if err != nil {
			log.Printf("Failed to accept connection: %v", err)
			continue
		}

		// 处理每个连接
		go handleSSHConnection(conn, sshConfig)
	}
}
