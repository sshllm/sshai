package main

import (
	"bufio"
	"bytes"
	"crypto/rand"
	"crypto/rsa"
	"crypto/x509"
	"encoding/json"
	"encoding/pem"
	"fmt"
	"io"
	"log"
	"net"
	"net/http"
	"os"
	"strings"
	"sync"
	"time"
	"unicode/utf8"

	"golang.org/x/crypto/ssh"
	"gopkg.in/yaml.v2"
)

// é…ç½®åŠ è½½å‡½æ•°
func loadConfig() error {
	data, err := os.ReadFile("config.yaml")
	if err != nil {
		return fmt.Errorf("è¯»å–é…ç½®æ–‡ä»¶å¤±è´¥: %v", err)
	}

	err = yaml.Unmarshal(data, &config)
	if err != nil {
		return fmt.Errorf("è§£æé…ç½®æ–‡ä»¶å¤±è´¥: %v", err)
	}

	return nil
}

// é…ç½®ç»“æ„ä½“
type Config struct {
	Server struct {
		Port           string `yaml:"port"`
		WelcomeMessage string `yaml:"welcome_message"`
		PromptTemplate string `yaml:"prompt_template"`
	} `yaml:"server"`
	API struct {
		BaseURL      string `yaml:"base_url"`
		APIKey       string `yaml:"api_key"`
		DefaultModel string `yaml:"default_model"`
		Timeout      int    `yaml:"timeout"`
	} `yaml:"api"`
	Display struct {
		LineWidth                 int `yaml:"line_width"`
		ThinkingAnimationInterval int `yaml:"thinking_animation_interval"`
		LoadingAnimationInterval  int `yaml:"loading_animation_interval"`
	} `yaml:"display"`
	Security struct {
		HostKeyFile string `yaml:"host_key_file"`
	} `yaml:"security"`
}

// å…¨å±€é…ç½®å˜é‡
var config Config

// OpenAI API è¯·æ±‚ç»“æ„ä½“
type ChatMessage struct {
	Role    string `json:"role"`
	Content string `json:"content"`
}

type ChatRequest struct {
	Model    string        `json:"model"`
	Messages []ChatMessage `json:"messages"`
	Stream   bool          `json:"stream"`
}

type ChatResponse struct {
	ID      string `json:"id"`
	Object  string `json:"object"`
	Created int64  `json:"created"`
	Model   string `json:"model"`
	Choices []struct {
		Index int `json:"index"`
		Delta struct {
			Role             string `json:"role,omitempty"`
			Content          string `json:"content,omitempty"`
			Reasoning        string `json:"reasoning,omitempty"`
			ReasoningContent string `json:"reasoning_content,omitempty"`
		} `json:"delta"`
		FinishReason *string `json:"finish_reason"`
	} `json:"choices"`
}

// æ¨¡å‹ä¿¡æ¯ç»“æ„ä½“
type ModelInfo struct {
	ID      string `json:"id"`
	Object  string `json:"object"`
	Created int64  `json:"created"`
	OwnedBy string `json:"owned_by"`
}

type ModelsResponse struct {
	Object string      `json:"object"`
	Data   []ModelInfo `json:"data"`
}

// AIAssistant çœŸå®AIåŠ©æ‰‹
type AIAssistant struct {
	messages      []ChatMessage
	currentModel  string
	username      string
	thinkingStart time.Time
}

func NewAIAssistant(username string) *AIAssistant {
	return &AIAssistant{
		messages:     make([]ChatMessage, 0),
		currentModel: config.API.DefaultModel,
		username:     username,
	}
}

func (ai *AIAssistant) ClearContext() {
	ai.messages = make([]ChatMessage, 0)
}

// è·å–å¯ç”¨æ¨¡å‹åˆ—è¡¨
func getAvailableModels() ([]ModelInfo, error) {
	req, err := http.NewRequest("GET", config.API.BaseURL+"/models", nil)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", "Bearer "+config.API.APIKey)

	client := &http.Client{Timeout: 10 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("APIé”™è¯¯: %d", resp.StatusCode)
	}

	var modelsResp ModelsResponse
	if err := json.NewDecoder(resp.Body).Decode(&modelsResp); err != nil {
		return nil, err
	}

	return modelsResp.Data, nil
}

// æ ¹æ®ç”¨æˆ·ååŒ¹é…æ¨¡å‹
func matchModelsByUsername(models []ModelInfo, username string) []ModelInfo {
	if username == "" {
		return models
	}

	var matched []ModelInfo
	username = strings.ToLower(username)

	for _, model := range models {
		modelName := strings.ToLower(model.ID)
		if strings.Contains(modelName, username) {
			matched = append(matched, model)
		}
	}

	return matched
}

// æ˜¾ç¤ºæ¨¡å‹é€‰æ‹©èœå•
func showModelSelection(channel ssh.Channel, models []ModelInfo, username string, allModels []ModelInfo) string {
	if len(models) == 0 {
		if len(allModels) > 0 {
			channel.Write([]byte(fmt.Sprintf("\r\næ²¡æœ‰æ‰¾åˆ°ä¸ç”¨æˆ·å '%s' åŒ¹é…çš„æ¨¡å‹ï¼Œæ˜¾ç¤ºæ‰€æœ‰å¯ç”¨æ¨¡å‹:\r\n", username)))
			models = allModels
		} else {
			channel.Write([]byte("\r\næ²¡æœ‰æ‰¾åˆ°å¯ç”¨çš„æ¨¡å‹\r\n"))
			return config.API.DefaultModel
		}
	}

	if len(models) == 1 {
		selectedModel := models[0].ID
		if username != "" {
			channel.Write([]byte(fmt.Sprintf("\r\nå·²ä¸ºç”¨æˆ· '%s' è‡ªåŠ¨é€‰æ‹©æ¨¡å‹: %s\r\n", username, selectedModel)))
		} else {
			channel.Write([]byte(fmt.Sprintf("\r\nå·²è‡ªåŠ¨é€‰æ‹©æ¨¡å‹: %s\r\n", selectedModel)))
		}
		return selectedModel
	}

	// æ˜¾ç¤ºæ¨¡å‹åˆ—è¡¨
	if username != "" {
		channel.Write([]byte(fmt.Sprintf("\r\nä¸ºç”¨æˆ· '%s' æ‰¾åˆ°ä»¥ä¸‹åŒ¹é…çš„æ¨¡å‹:\r\n", username)))
	} else {
		channel.Write([]byte("\r\nå¯ç”¨æ¨¡å‹åˆ—è¡¨:\r\n"))
	}

	for i, model := range models {
		channel.Write([]byte(fmt.Sprintf("%d. %s\r\n", i+1, model.ID)))
	}

	channel.Write([]byte("\r\nè¯·é€‰æ‹©æ¨¡å‹ (è¾“å…¥æ•°å­—): "))

	// è¯»å–ç”¨æˆ·é€‰æ‹© - æ”¹è¿›çš„è¾“å…¥å¤„ç†
	var inputBuffer []byte
	var incompleteUTF8 []byte
	buffer := make([]byte, 1024)

	for {
		n, err := channel.Read(buffer)
		if err != nil {
			return config.API.DefaultModel
		}

		data := buffer[:n]

		// å¤„ç†å¯èƒ½çš„ä¸å®Œæ•´UTF-8åºåˆ—
		if len(incompleteUTF8) > 0 {
			data = append(incompleteUTF8, data...)
			incompleteUTF8 = nil
		}

		// å¤„ç†UTF-8å­—ç¬¦
		for len(data) > 0 {
			r, size := utf8.DecodeRune(data)

			if r == utf8.RuneError && size == 1 {
				// å¯èƒ½æ˜¯ä¸å®Œæ•´çš„UTF-8åºåˆ—
				if len(data) < 4 {
					incompleteUTF8 = make([]byte, len(data))
					copy(incompleteUTF8, data)
					break
				}
				// è·³è¿‡æ— æ•ˆå­—èŠ‚
				data = data[1:]
				continue
			}

			data = data[size:]

			switch r {
			case '\r', '\n':
				// å¤„ç†å›è½¦æ¢è¡Œ
				if len(inputBuffer) > 0 {
					input := strings.TrimSpace(string(inputBuffer))
					inputBuffer = nil

					if input == "" {
						channel.Write([]byte("\r\nè¯·è¾“å…¥æœ‰æ•ˆçš„æ•°å­—: "))
						continue
					}

					// è§£æé€‰æ‹©
					choice := 0
					if _, err := fmt.Sscanf(input, "%d", &choice); err != nil {
						channel.Write([]byte("\r\næ— æ•ˆè¾“å…¥ï¼Œè¯·è¾“å…¥æ•°å­—: "))
						continue
					}

					if choice < 1 || choice > len(models) {
						channel.Write([]byte(fmt.Sprintf("\r\nè¯·è¾“å…¥ 1-%d ä¹‹é—´çš„æ•°å­—: ", len(models))))
						continue
					}

					selectedModel := models[choice-1].ID
					channel.Write([]byte(fmt.Sprintf("\r\nå·²é€‰æ‹©æ¨¡å‹: %s\r\n", selectedModel)))
					return selectedModel
				} else {
					channel.Write([]byte("\r\nè¯·è¾“å…¥æœ‰æ•ˆçš„æ•°å­—: "))
				}

			case 127, 8: // Backspace/Delete
				if len(inputBuffer) > 0 {
					// åˆ é™¤æœ€åä¸€ä¸ªUTF-8å­—ç¬¦
					inputStr := string(inputBuffer)
					if len(inputStr) > 0 {
						runes := []rune(inputStr)
						if len(runes) > 0 {
							lastRune := runes[len(runes)-1]
							newStr := string(runes[:len(runes)-1])
							inputBuffer = []byte(newStr)

							// æ ¹æ®å­—ç¬¦å®½åº¦å‘é€é€€æ ¼åºåˆ—
							if utf8.RuneLen(lastRune) > 1 {
								// ä¸­æ–‡å­—ç¬¦éœ€è¦ä¸¤ä¸ªé€€æ ¼
								channel.Write([]byte("\b \b\b \b"))
							} else {
								// è‹±æ–‡å­—ç¬¦ä¸€ä¸ªé€€æ ¼
								channel.Write([]byte("\b \b"))
							}
						}
					}
				}

			case 3: // Ctrl+C
				channel.Write([]byte("\r\n^C\r\n"))
				return config.API.DefaultModel

			default:
				// å¤„ç†æ•°å­—è¾“å…¥
				if r >= '0' && r <= '9' {
					runeBytes := make([]byte, utf8.RuneLen(r))
					utf8.EncodeRune(runeBytes, r)
					inputBuffer = append(inputBuffer, runeBytes...)
					channel.Write(runeBytes) // å›æ˜¾å­—ç¬¦
				}
			}
		}
	}
}

func (ai *AIAssistant) ProcessMessage(input string, channel ssh.Channel, interrupt chan bool) {
	input = strings.TrimSpace(input)

	// æ£€æŸ¥ç‰¹æ®Šå‘½ä»¤
	if strings.ToLower(input) == "/new" {
		ai.ClearContext()
		channel.Write([]byte("\r\n[æ–°ä¼šè¯å·²åˆ›å»º]\r\n"))
		return
	}

	if input == "" {
		return
	}

	// æ·»åŠ ç”¨æˆ·æ¶ˆæ¯åˆ°ä¸Šä¸‹æ–‡
	ai.messages = append(ai.messages, ChatMessage{
		Role:    "user",
		Content: input,
	})

	// æ˜¾ç¤ºåŠ è½½åŠ¨ç”»å¹¶è°ƒç”¨AI API
	ai.callAIAPIWithLoading(channel, interrupt)
}

// æ˜¾ç¤ºåŠ è½½åŠ¨ç”»çš„AI APIè°ƒç”¨
func (ai *AIAssistant) callAIAPIWithLoading(channel ssh.Channel, interrupt chan bool) {
	// å¯åŠ¨åŠ è½½åŠ¨ç”»
	var wg sync.WaitGroup
	stopLoading := make(chan bool)

	wg.Add(1)
	go func() {
		defer wg.Done()
		ai.showLoadingAnimation(channel, stopLoading)
	}()

	// è°ƒç”¨AI API
	ai.callAIAPI(channel, stopLoading, interrupt)

	// ç­‰å¾…åŠ è½½åŠ¨ç”»ç»“æŸ
	wg.Wait()
}

// åŠ è½½åŠ¨ç”»
func (ai *AIAssistant) showLoadingAnimation(channel ssh.Channel, stop chan bool) {
	loadingChars := []string{"â ‹", "â ™", "â ¹", "â ¸", "â ¼", "â ´", "â ¦", "â §", "â ‡", "â "}
	i := 0

	channel.Write([]byte("\r\n"))

	ticker := time.NewTicker(100 * time.Millisecond)
	defer ticker.Stop()

	for {
		select {
		case <-stop:
			// æ¸…é™¤åŠ è½½åŠ¨ç”»
			channel.Write([]byte("\r\033[K"))
			return
		case <-ticker.C:
			// æ˜¾ç¤ºåŠ è½½åŠ¨ç”»
			channel.Write([]byte(fmt.Sprintf("\r%s ", loadingChars[i%len(loadingChars)])))
			i++
		}
	}
}

// æ€è€ƒåŠ¨ç”»
func (ai *AIAssistant) showThinkingAnimation(channel ssh.Channel, interrupt chan bool) {
	thinkingChars := []string{"â ‹", "â ™", "â ¹", "â ¸", "â ¼", "â ´", "â ¦", "â §", "â ‡", "â "}
	i := 0

	channel.Write([]byte("\r\n--- æ€è€ƒä¸­ ---\r\n"))

	ticker := time.NewTicker(100 * time.Millisecond)
	defer ticker.Stop()

	for {
		select {
		case <-interrupt:
			// æ¸…é™¤æ€è€ƒåŠ¨ç”»
			channel.Write([]byte("\r\033[K"))
			return
		case <-ticker.C:
			// æ˜¾ç¤ºæ€è€ƒåŠ¨ç”»
			channel.Write([]byte(fmt.Sprintf("\r%s æ€è€ƒä¸­...", thinkingChars[i%len(thinkingChars)])))
			i++
		}
	}
}

// è‡ªåŠ¨æ¢è¡Œå‡½æ•°
func wrapText(text string, width int) string {
	if width <= 0 {
		return text
	}

	var result strings.Builder
	var currentLine strings.Builder
	var currentWidth int

	for _, r := range text {
		if r == '\n' {
			result.WriteString(currentLine.String())
			result.WriteRune('\n')
			currentLine.Reset()
			currentWidth = 0
			continue
		}

		runeWidth := 1
		if utf8.RuneLen(r) > 1 {
			runeWidth = 2 // ä¸­æ–‡å­—ç¬¦å 2ä¸ªå®½åº¦
		}

		if currentWidth+runeWidth > width && currentLine.Len() > 0 {
			result.WriteString(currentLine.String())
			result.WriteString("\r\n")
			currentLine.Reset()
			currentWidth = 0
		}

		currentLine.WriteRune(r)
		currentWidth += runeWidth
	}

	if currentLine.Len() > 0 {
		result.WriteString(currentLine.String())
	}

	return result.String()
}

func (ai *AIAssistant) callAIAPI(channel ssh.Channel, stopLoading chan bool, interrupt chan bool) {
	// æ„å»ºè¯·æ±‚
	request := ChatRequest{
		Model:    ai.currentModel,
		Messages: ai.messages,
		Stream:   true,
	}

	jsonData, err := json.Marshal(request)
	if err != nil {
		stopLoading <- true
		channel.Write([]byte(fmt.Sprintf("\r\n[é”™è¯¯: %v]\r\n", err)))
		return
	}

	// åˆ›å»ºHTTPè¯·æ±‚
	req, err := http.NewRequest("POST", config.API.BaseURL+"/chat/completions", bytes.NewBuffer(jsonData))
	if err != nil {
		stopLoading <- true
		channel.Write([]byte(fmt.Sprintf("\r\n[é”™è¯¯: %v]\r\n", err)))
		return
	}

	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+config.API.APIKey)

	// å‘é€è¯·æ±‚
	client := &http.Client{Timeout: time.Duration(config.API.Timeout) * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		stopLoading <- true
		channel.Write([]byte(fmt.Sprintf("\r\n[ç½‘ç»œé”™è¯¯: %v]\r\n", err)))
		return
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		stopLoading <- true
		channel.Write([]byte(fmt.Sprintf("\r\n[APIé”™è¯¯: %d]\r\n", resp.StatusCode)))
		return
	}

	// å¤„ç†æµå¼å“åº”
	scanner := bufio.NewScanner(resp.Body)
	var assistantMessage strings.Builder
	var currentLine strings.Builder
	const lineWidth = 80 // ç»ˆç«¯å®½åº¦

	isThinking := false
	hasContent := false

	for scanner.Scan() {
		// æ£€æŸ¥æ˜¯å¦è¢«ä¸­æ–­
		select {
		case <-interrupt:
			if !hasContent {
				stopLoading <- true
			}
			channel.Write([]byte("\r\n[å›ç­”å·²ä¸­æ–­]\r\n"))
			return
		default:
		}

		line := scanner.Text()
		if !strings.HasPrefix(line, "data: ") {
			continue
		}

		data := strings.TrimPrefix(line, "data: ")
		if data == "[DONE]" {
			break
		}

		var response ChatResponse
		if err := json.Unmarshal([]byte(data), &response); err != nil {
			continue
		}

		if len(response.Choices) > 0 {
			choice := response.Choices[0]

			// æ£€æŸ¥æ˜¯å¦æœ‰æ€è€ƒå†…å®¹ (æ”¯æŒå¤šç§å­—æ®µå)
			thinkingContent := ""
			if choice.Delta.Reasoning != "" {
				thinkingContent = choice.Delta.Reasoning
			} else if choice.Delta.ReasoningContent != "" {
				thinkingContent = choice.Delta.ReasoningContent
			}

			if thinkingContent != "" {
				if !isThinking {
					// ç¬¬ä¸€æ¬¡æ”¶åˆ°æ€è€ƒå†…å®¹ï¼Œåœæ­¢æ™®é€šåŠ è½½åŠ¨ç”»ï¼Œæ˜¾ç¤ºæ€è€ƒçŠ¶æ€
					stopLoading <- true
					isThinking = true
					ai.thinkingStart = time.Now()
					channel.Write([]byte("\r\033[KğŸ¤– Thinking\r\n"))
				}

				// ç›´æ¥æ˜¾ç¤ºæ€è€ƒå†…å®¹ï¼Œä¸æ˜¾ç¤ºåŠ¨ç”»
				reasoning := thinkingContent
				for _, r := range reasoning {
					if r == '\n' {
						channel.Write([]byte(currentLine.String() + "\r\n"))
						currentLine.Reset()
					} else {
						currentLine.WriteRune(r)
						if ai.getDisplayWidth(currentLine.String()) >= lineWidth {
							lineStr := currentLine.String()
							breakPos := ai.findBreakPosition(lineStr, lineWidth)
							if breakPos > 0 {
								channel.Write([]byte(lineStr[:breakPos] + "\r\n"))
								currentLine.Reset()
								currentLine.WriteString(lineStr[breakPos:])
							} else {
								channel.Write([]byte(currentLine.String() + "\r\n"))
								currentLine.Reset()
							}
						}
					}
				}
			}

			// æ£€æŸ¥æ˜¯å¦æœ‰å›ç­”å†…å®¹
			if choice.Delta.Content != "" {
				if !hasContent {
					// ç¬¬ä¸€æ¬¡æ”¶åˆ°å›ç­”å†…å®¹
					if isThinking {
						// å¦‚æœä¹‹å‰åœ¨æ€è€ƒï¼Œå…ˆè¾“å‡ºå‰©ä½™æ€è€ƒå†…å®¹å¹¶æ˜¾ç¤ºå®ŒæˆçŠ¶æ€
						if currentLine.Len() > 0 {
							channel.Write([]byte(currentLine.String() + "\r\n"))
							currentLine.Reset()
						}
						// è®¡ç®—æ€è€ƒæ—¶é—´
						thinkingDuration := time.Since(ai.thinkingStart)
						channel.Write([]byte(fmt.Sprintf("âœ… Doneï¼š %.1fs\r\n", thinkingDuration.Seconds())))
					} else {
						stopLoading <- true
					}
					hasContent = true
				}

				content := choice.Delta.Content
				assistantMessage.WriteString(content)

				// å¤„ç†è‡ªåŠ¨æ¢è¡Œ
				for _, r := range content {
					if r == '\n' {
						channel.Write([]byte(currentLine.String() + "\r\n"))
						currentLine.Reset()
					} else {
						currentLine.WriteRune(r)
						if ai.getDisplayWidth(currentLine.String()) >= lineWidth {
							lineStr := currentLine.String()
							breakPos := ai.findBreakPosition(lineStr, lineWidth)
							if breakPos > 0 {
								channel.Write([]byte(lineStr[:breakPos] + "\r\n"))
								currentLine.Reset()
								currentLine.WriteString(lineStr[breakPos:])
							} else {
								channel.Write([]byte(currentLine.String() + "\r\n"))
								currentLine.Reset()
							}
						}
					}
				}
			}
		}
	}

	// å¦‚æœæ²¡æœ‰æ”¶åˆ°ä»»ä½•å†…å®¹ï¼Œåœæ­¢åŠ è½½åŠ¨ç”»
	if !hasContent && !isThinking {
		stopLoading <- true
	}

	// è¾“å‡ºå‰©ä½™å†…å®¹
	if currentLine.Len() > 0 {
		channel.Write([]byte(currentLine.String()))
	}

	// å°†åŠ©æ‰‹å›å¤æ·»åŠ åˆ°ä¸Šä¸‹æ–‡
	if assistantMessage.Len() > 0 {
		ai.messages = append(ai.messages, ChatMessage{
			Role:    "assistant",
			Content: assistantMessage.String(),
		})
	}

	channel.Write([]byte("\r\n"))
}

// è®¡ç®—æ˜¾ç¤ºå®½åº¦ï¼ˆä¸­æ–‡å­—ç¬¦å 2ä¸ªå®½åº¦ï¼‰
func (ai *AIAssistant) getDisplayWidth(text string) int {
	width := 0
	for _, r := range text {
		if utf8.RuneLen(r) > 1 {
			width += 2 // ä¸­æ–‡å­—ç¬¦
		} else {
			width += 1 // è‹±æ–‡å­—ç¬¦
		}
	}
	return width
}

// å¯»æ‰¾åˆé€‚çš„æ–­è¡Œä½ç½®
func (ai *AIAssistant) findBreakPosition(text string, maxWidth int) int {
	if len(text) == 0 {
		return 0
	}

	// å¯»æ‰¾ç©ºæ ¼ã€æ ‡ç‚¹ç¬¦å·ç­‰åˆé€‚çš„æ–­è¡Œä½ç½®
	breakChars := []rune{' ', ',', '.', '!', '?', ';', ':', 'ï¼Œ', 'ã€‚', 'ï¼', 'ï¼Ÿ', 'ï¼›', 'ï¼š'}

	currentWidth := 0
	lastBreakBytePos := 0
	currentBytePos := 0

	for _, r := range text {
		runeWidth := 1
		if utf8.RuneLen(r) > 1 {
			runeWidth = 2
		}

		currentWidth += runeWidth

		// æ£€æŸ¥æ˜¯å¦æ˜¯æ–­è¡Œå­—ç¬¦
		for _, bc := range breakChars {
			if r == bc {
				lastBreakBytePos = currentBytePos + utf8.RuneLen(r)
				break
			}
		}

		if currentWidth >= maxWidth {
			if lastBreakBytePos > 0 {
				return lastBreakBytePos
			}
			// å¦‚æœæ²¡æœ‰æ‰¾åˆ°åˆé€‚çš„æ–­è¡Œä½ç½®ï¼Œè¿”å›å½“å‰å­—ç¬¦çš„èµ·å§‹ä½ç½®
			return currentBytePos
		}

		currentBytePos += utf8.RuneLen(r)
	}

	return 0
}

// ç”Ÿæˆæˆ–åŠ è½½RSAä¸»æœºå¯†é’¥
func generateHostKey() (ssh.Signer, error) {
	keyFile := config.Security.HostKeyFile

	// å°è¯•åŠ è½½ç°æœ‰å¯†é’¥
	if keyData, err := os.ReadFile(keyFile); err == nil {
		privateKey, err := ssh.ParsePrivateKey(keyData)
		if err == nil {
			log.Printf("å·²åŠ è½½ç°æœ‰ä¸»æœºå¯†é’¥")
			return privateKey, nil
		}
		log.Printf("æ— æ³•è§£æç°æœ‰å¯†é’¥æ–‡ä»¶ï¼Œå°†ç”Ÿæˆæ–°å¯†é’¥: %v", err)
	}

	// ç”Ÿæˆæ–°çš„RSAç§é’¥
	privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
	if err != nil {
		return nil, err
	}

	// å°†ç§é’¥è½¬æ¢ä¸ºSSHç­¾åå™¨
	signer, err := ssh.NewSignerFromKey(privateKey)
	if err != nil {
		return nil, err
	}

	// ä¿å­˜ç§é’¥åˆ°æ–‡ä»¶
	keyBytes := x509.MarshalPKCS1PrivateKey(privateKey)
	keyPEM := pem.EncodeToMemory(&pem.Block{
		Type:  "RSA PRIVATE KEY",
		Bytes: keyBytes,
	})

	if err := os.WriteFile(keyFile, keyPEM, 0600); err != nil {
		log.Printf("è­¦å‘Šï¼šæ— æ³•ä¿å­˜ä¸»æœºå¯†é’¥: %v", err)
	} else {
		log.Printf("å·²ç”Ÿæˆå¹¶ä¿å­˜æ–°çš„ä¸»æœºå¯†é’¥")
	}

	return signer, nil
}

func handleSSHConnection(conn net.Conn, config *ssh.ServerConfig) {
	defer conn.Close()

	// SSHæ¡æ‰‹
	sshConn, chans, reqs, err := ssh.NewServerConn(conn, config)
	if err != nil {
		log.Printf("Failed to handshake: %v", err)
		return
	}
	defer sshConn.Close()

	// è·å–ç”¨æˆ·å
	username := sshConn.User()
	log.Printf("New SSH connection from %s (%s), user: %s", sshConn.RemoteAddr(), sshConn.ClientVersion(), username)

	// å¤„ç†å…¨å±€è¯·æ±‚
	go ssh.DiscardRequests(reqs)

	// å¤„ç†é€šé“
	for newChannel := range chans {
		if newChannel.ChannelType() != "session" {
			newChannel.Reject(ssh.UnknownChannelType, "unknown channel type")
			continue
		}

		channel, requests, err := newChannel.Accept()
		if err != nil {
			log.Printf("Could not accept channel: %v", err)
			continue
		}

		go handleSession(channel, requests, username)
	}
}

func handleSession(channel ssh.Channel, requests <-chan *ssh.Request, username string) {
	defer channel.Close()

	// å‘é€æ¬¢è¿æ¶ˆæ¯
	if username != "" {
		channel.Write([]byte(fmt.Sprintf("æ¬¢è¿, %s!\r\n", username)))
	} else {
		channel.Write([]byte(config.Server.WelcomeMessage + "\r\n"))
	}

	// è·å–å¹¶é€‰æ‹©æ¨¡å‹
	channel.Write([]byte("æ­£åœ¨è·å–å¯ç”¨æ¨¡å‹...\r\n"))
	models, err := getAvailableModels()
	if err != nil {
		channel.Write([]byte(fmt.Sprintf("è·å–æ¨¡å‹åˆ—è¡¨å¤±è´¥: %v\r\n", err)))
		channel.Write([]byte(fmt.Sprintf("ä½¿ç”¨é»˜è®¤æ¨¡å‹: %s\r\n", config.API.DefaultModel)))
		models = []ModelInfo{{ID: config.API.DefaultModel}}
	}

	// æ ¹æ®ç”¨æˆ·ååŒ¹é…æ¨¡å‹
	matchedModels := matchModelsByUsername(models, username)
	selectedModel := showModelSelection(channel, matchedModels, username, models)

	// åˆ›å»ºAIåŠ©æ‰‹å®ä¾‹
	ai := NewAIAssistant(username)
	ai.currentModel = selectedModel
	interrupt := make(chan bool, 1)

	// æ˜¾ç¤ºå¯¹è¯æç¤ºç¬¦
	dynamicPrompt := fmt.Sprintf(config.Server.PromptTemplate, selectedModel)
	channel.Write([]byte("\r\n" + dynamicPrompt))

	// å¤„ç†ä¼šè¯è¯·æ±‚
	go func() {
		for req := range requests {
			switch req.Type {
			case "shell", "exec":
				req.Reply(true, nil)
			case "pty-req":
				req.Reply(true, nil)
			default:
				req.Reply(false, nil)
			}
		}
	}()

	// ä¸»è¦çš„äº¤äº’å¾ªç¯ - æ”¯æŒUTF-8è¾“å…¥
	buffer := make([]byte, 4096) // å¢å¤§ç¼“å†²åŒºä»¥æ”¯æŒUTF-8
	var inputBuffer []byte
	var incompleteUTF8 []byte

	for {
		n, err := channel.Read(buffer)
		if err != nil {
			if err != io.EOF {
				log.Printf("Read error: %v", err)
			}
			break
		}

		data := buffer[:n]

		// å¤„ç†å¯èƒ½çš„ä¸å®Œæ•´UTF-8åºåˆ—
		if len(incompleteUTF8) > 0 {
			data = append(incompleteUTF8, data...)
			incompleteUTF8 = nil
		}

		// å¤„ç†UTF-8å­—ç¬¦
		for len(data) > 0 {
			r, size := utf8.DecodeRune(data)

			if r == utf8.RuneError && size == 1 {
				// å¯èƒ½æ˜¯ä¸å®Œæ•´çš„UTF-8åºåˆ—
				if len(data) < 4 {
					incompleteUTF8 = make([]byte, len(data))
					copy(incompleteUTF8, data)
					break
				}
				// è·³è¿‡æ— æ•ˆå­—èŠ‚
				data = data[1:]
				continue
			}

			data = data[size:]

			switch r {
			case '\r', '\n':
				// å¤„ç†å›è½¦æ¢è¡Œ
				if len(inputBuffer) > 0 {
					input := string(inputBuffer)
					inputBuffer = nil

					// æ£€æŸ¥é€€å‡ºå‘½ä»¤
					if strings.ToLower(strings.TrimSpace(input)) == "exit" {
						channel.Write([]byte("\r\nGoodbye!\r\n"))
						return
					}

					// è°ƒç”¨AIå¤„ç†æ¶ˆæ¯
					ai.ProcessMessage(input, channel, interrupt)
				} else {
					channel.Write([]byte("\r\n"))
				}
				channel.Write([]byte(dynamicPrompt))

			case 127, 8: // Backspace/Delete
				if len(inputBuffer) > 0 {
					// åˆ é™¤æœ€åä¸€ä¸ªUTF-8å­—ç¬¦
					inputStr := string(inputBuffer)
					if len(inputStr) > 0 {
						runes := []rune(inputStr)
						if len(runes) > 0 {
							lastRune := runes[len(runes)-1]
							newStr := string(runes[:len(runes)-1])
							inputBuffer = []byte(newStr)

							// æ ¹æ®å­—ç¬¦å®½åº¦å‘é€é€€æ ¼åºåˆ—
							if utf8.RuneLen(lastRune) > 1 {
								// ä¸­æ–‡å­—ç¬¦éœ€è¦ä¸¤ä¸ªé€€æ ¼
								channel.Write([]byte("\b \b\b \b"))
							} else {
								// è‹±æ–‡å­—ç¬¦ä¸€ä¸ªé€€æ ¼
								channel.Write([]byte("\b \b"))
							}
						}
					}
				}

			case 3: // Ctrl+C
				// å‘é€ä¸­æ–­ä¿¡å·
				select {
				case interrupt <- true:
				default:
				}
				channel.Write([]byte("\r\n^C\r\n"))
				channel.Write([]byte(dynamicPrompt))
				inputBuffer = nil

			default:
				// å¤„ç†æ‰€æœ‰å¯æ‰“å°å­—ç¬¦ï¼ŒåŒ…æ‹¬ä¸­æ–‡
				if r >= 32 || (r > 127 && utf8.ValidRune(r)) {
					runeBytes := make([]byte, utf8.RuneLen(r))
					utf8.EncodeRune(runeBytes, r)
					inputBuffer = append(inputBuffer, runeBytes...)
					channel.Write(runeBytes) // å›æ˜¾å­—ç¬¦
				}
			}
		}
	}
}

func main() {
	// åŠ è½½é…ç½®æ–‡ä»¶
	err := loadConfig()
	if err != nil {
		log.Fatal("Failed to load config:", err)
	}

	// ç”Ÿæˆä¸»æœºå¯†é’¥
	hostKey, err := generateHostKey()
	if err != nil {
		log.Fatal("Failed to generate host key:", err)
	}

	// SSHæœåŠ¡å™¨é…ç½®
	sshConfig := &ssh.ServerConfig{
		// æ— å¯†ç è®¤è¯ - æ¥å—æ‰€æœ‰è¿æ¥
		NoClientAuth: true,
		// æˆ–è€…ä½¿ç”¨å¯†ç å›è°ƒæ¥æ¥å—ä»»ä½•å¯†ç 
		PasswordCallback: func(conn ssh.ConnMetadata, password []byte) (*ssh.Permissions, error) {
			// æ¥å—ä»»ä½•ç”¨æˆ·åå’Œå¯†ç 
			log.Printf("Login attempt: user=%s", conn.User())
			return nil, nil
		},
		PublicKeyCallback: func(conn ssh.ConnMetadata, key ssh.PublicKey) (*ssh.Permissions, error) {
			// æ¥å—ä»»ä½•å…¬é’¥
			return nil, nil
		},
	}

	sshConfig.AddHostKey(hostKey)

	// ç›‘å¬ç«¯å£
	listener, err := net.Listen("tcp", ":"+config.Server.Port)
	if err != nil {
		log.Fatal("Failed to listen on port", config.Server.Port, ":", err)
	}
	defer listener.Close()

	log.Printf("SSH AI Server listening on port %s", config.Server.Port)
	log.Printf("Connect with: ssh gpt-5@localhost -p %s", config.Server.Port)

	// æ¥å—è¿æ¥
	for {
		conn, err := listener.Accept()
		if err != nil {
			log.Printf("Failed to accept connection: %v", err)
			continue
		}

		// å¤„ç†æ¯ä¸ªè¿æ¥
		go handleSSHConnection(conn, sshConfig)
	}
}
